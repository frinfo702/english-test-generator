/**
 * Questions loader â€” fetches pre-generated JSON problem files from public/questions/.
 *
 * Problem files are generated by AI (Claude Code / Claude agent) and saved as JSON.
 * The frontend only reads these files; no network/API calls to AI are made at runtime.
 *
 * Directory structure (under public/questions/):
 *   toefl/reading/complete-words/      *.json
 *   toefl/reading/daily-life/          *.json
 *   toefl/reading/academic/            *.json
 *   toefl/writing/build-sentence/      *.json
 *   toefl/writing/email/               *.json
 *   toefl/writing/discussion/          *.json
 *   toefl/speaking/listen-repeat/      *.json
 *   toefl/speaking/interview/          *.json
 *   toeic/part5/                       *.json
 *   toeic/part6/                       *.json
 *   toeic/part7/                       *.json
 *
 * Each directory has an index.json listing available files:
 *   { "files": ["001.json", "002.json", ...] }
 */

export interface QuestionIndex {
  files: string[];
}

export interface LoadedQuestion<T> {
  data: T;
  file: string;
}

export interface QuestionFileEntry {
  file: string;
  number: number;
}

export async function fetchQuestionIndex(
  taskPath: string,
): Promise<QuestionIndex> {
  const res = await fetch(`/questions/${taskPath}/index.json`);
  if (!res.ok)
    throw new Error(`No questions found for ${taskPath}. Generate some first!`);
  return res.json();
}

export async function fetchRandomQuestion<T>(taskPath: string): Promise<T> {
  const loaded = await fetchRandomQuestionWithMeta<T>(taskPath);
  return loaded.data;
}

export async function listQuestionFiles(
  taskPath: string,
): Promise<QuestionFileEntry[]> {
  const index = await fetchQuestionIndex(taskPath);
  return index.files
    .map((file) => {
      const basename = file.replace(/\.[^.]+$/, "");
      if (!/^\d+$/.test(basename)) {
        throw new Error(
          `Question file "${file}" in ${taskPath} must use numeric filename like 001.json.`,
        );
      }
      return {
        file,
        number: Number.parseInt(basename, 10),
      };
    })
    .sort((a, b) => a.number - b.number || a.file.localeCompare(b.file));
}

export async function fetchQuestionByFileWithMeta<T>(
  taskPath: string,
  file: string,
): Promise<LoadedQuestion<T>> {
  const res = await fetch(`/questions/${taskPath}/${file}`);
  if (!res.ok) throw new Error(`Failed to load question file: ${file}`);
  const data = (await res.json()) as T;
  return { data, file };
}

export async function fetchQuestionByNumberWithMeta<T>(
  taskPath: string,
  questionNumber: number,
): Promise<LoadedQuestion<T>> {
  const files = await listQuestionFiles(taskPath);
  const selected = files.find((item) => item.number === questionNumber);
  if (!selected) {
    throw new Error(
      `Question ${questionNumber} not found in ${taskPath}. Generate or register it first.`,
    );
  }
  return fetchQuestionByFileWithMeta<T>(taskPath, selected.file);
}

export async function fetchRandomQuestionWithMeta<T>(
  taskPath: string,
): Promise<LoadedQuestion<T>> {
  const files = await listQuestionFiles(taskPath);
  if (files.length === 0) {
    throw new Error(`No question files in ${taskPath}. Generate some first!`);
  }
  const selected = files[Math.floor(Math.random() * files.length)];
  return fetchQuestionByFileWithMeta<T>(taskPath, selected.file);
}

export async function fetchAllQuestions<T>(taskPath: string): Promise<T[]> {
  const index = await fetchQuestionIndex(taskPath);
  const results = await Promise.all(
    index.files.map(async (file) => {
      const res = await fetch(`/questions/${taskPath}/${file}`);
      if (!res.ok) throw new Error(`Failed to load: ${file}`);
      return res.json() as Promise<T>;
    })
  );
  return results;
}
